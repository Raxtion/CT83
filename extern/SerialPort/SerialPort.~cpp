//---------------------------------------------------------------------------


#pragma hdrstop
#include <vcl>

#include "SerialPort.h"
#include <stdio.h>



#define MAX_BUFFER 300

//---------------------------------------------------------------------------

#pragma package(smart_init)
//---------------------------------------------------------------------------
__fastcall CSerialPort::CSerialPort()
{

}
//---------------------------------------------------------------------------
__fastcall CSerialPort::~CSerialPort()
{
        sio_close(m_nPortNo);
}
//---------------------------------------------------------------------------
bool __fastcall CSerialPort::Open(int nPort,int nBaudRate,int nMode)
{
        m_nPortNo=nPort;
  if(sio_open(nPort)!=SIO_OK)
    return false;

  //if(sio_ioctl(nPort,B9600,BIT_8|STOP_1|P_NONE)!=SIO_OK)
        if( sio_ioctl(nPort,nBaudRate,nMode) != SIO_OK )
                return false;

  //sio_SetReadTimeouts(nPort,MAXDWORD,2000);

	return true;
}
//---------------------------------------------------------------------------
bool __fastcall CSerialPort::WriteData(char *pBuffer,int nLen)
{

        sio_flush(m_nPortNo,2);          //0: input buffer 1:outputbuffer 2:both

        int L=strlen(pBuffer);
        if(nLen!=0)     L=nLen;
        if(sio_write(m_nPortNo,pBuffer,L)<0)
        return false;

        return true;
}
//---------------------------------------------------------------------------
bool __fastcall CSerialPort::ReadData(char *pBuffer,char EndByte,int nTimeOut)
{
        DWORD dwStart=GetTickCount();
        char Rx[MAX_BUFFER]={0};
        int nIndex=0;
        int nRet;
        while(1)
        {
                nRet=sio_read(m_nPortNo,pBuffer,MAX_BUFFER);
                if(nRet>0)
                { 
                        strncpy(Rx+nIndex,pBuffer,nRet);
                        nIndex+=nRet;
                         if(pBuffer[nRet-1]==EndByte)
                         {
                                strcpy(pBuffer,Rx);
                                return true;
                         }
                         else if(EndByte == 0x00)       //non end byte
                         {
                                strcpy(pBuffer,Rx);
                                return true;
                         }
                }
                if(nRet<0) return false;

                if((GetTickCount()-dwStart)>nTimeOut) break;
                ::Sleep(1);
                
        }

    return false;

}
//---------------------------------------------------------------------------
bool __fastcall CSerialPort::ReadSizeData(char *pBuffer,int nTimeOut)
{
        sio_flush(m_nPortNo,0)
        ::Sleep(300);
        DWORD dwStart=GetTickCount();
        char Rx[MAX_BUFFER]={0};

        int nRet; 
        
        while(1)
        {

                nRet=sio_read(m_nPortNo,pBuffer,MAX_BUFFER);
                if(nRet>0)
                {
                        strncpy(Rx,pBuffer,nRet);
                        return true;

                }
                if(nRet<0) return false;

                if((GetTickCount()-dwStart)>nTimeOut) break;
                ::Sleep(1);
                
        }

    return false;

}

